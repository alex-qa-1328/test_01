# Модуль 10. Основы Python. Часть 2
import datetime

day = datetime.datetime.now().date()    # Глобальная переменная

# Что такое функции и работа с ними
# Функции в Python – это именованные блоки кода, которые выполняют определенную задачу.
# Функция определяется с помощью ключевого слова ‘def’, за которым следует имя функции, параметры (если есть) и двоеточие.
# Тело функции находится в блоке, отступ которого выполняется с помощью табуляции (TAB) - обычно 4 пробела.

def show_time():    # функция без параметров, возвращает текущее время без даты
    current_time = datetime.datetime.now().time()   # Локальная переменная
    return current_time
    # print(current_time)

# print(show_time())
# show_time()
# print(current_time)

debug = "debug"

def phone_call(my_number: int, destination_number: int, option = None):   # функция с параметрами
    # Тело функции, здесь написана вся логика выполнения функции
    if len(str(my_number)) != 11 or len(str(destination_number)) != 11:     # ==  !=
        print("Введён некорректный номер телефона")
    else:
        if my_number == destination_number:
            print(f"Вы не можете звонить самому себе! Ваш номер: {my_number}")
        else:
            print(f"Исходящий вызов на номер: {destination_number}")
            if option == debug:
                print(f"Ваш номер телефона: {my_number}\nВремя начала звонка: {show_time()}")
            elif option is None:
                return option
            else:
                print(f"Неверная опция звонка!")

# Всё что начинается с начала строки уже не входит в метод
# Для вызова метода нужно лишь указать его название и обязательные атрибуты (если есть)

# phone_call(79017776040, 88005553535)
# phone_call(79017776040, 88005553535, option=debug)
# phone_call(123, 89099992030)
# phone_call()

# Область видимости переменных
# Область видимости (scope) в Python определяет, где в коде можно получить доступ к переменной.
# Глобальный уровень (Global) – это область видимости, в которой находятся переменные, определенные на верхнем уровне вашего модуля (файла).
# Локальный уровень (Local) – это область видимости, в которой находятся переменные, определенные внутри функций или других блоков кода.

# print(current_time)     # Попытка воспользоваться локальной переменной, которая недоступна глобально в модуле
# print(day)      # Используем ГЛОБАЛЬНУЮ переменную, которая доступна во всём модуле (файле)

# Условные операторы if, else, elif
# if - Если
# else - Всё остальное
# elif - Также если  else if

v_220 = 220
powerbank = "powerbank"

def boile_kettle(water, water_check, power = v_220):
    if power == v_220 or power == powerbank:    # Оператор 'or' (или) проверяет чтобы хотя бы одно из условий было соблюдено
        if not water_check: # Равносильно выражению if water_check == False
            if 200 <= water < 1000: # равносильно написанию if water >= 200 and water < 1000
                if water <= 400:
                    time = 30
                elif 400 < water <= 600:    # оператор and проверяет чтобы каждое из условий было соблюдено
                    time = 50
                else:
                    time = 80
                print(f"Чайник с объемом {water} мл закипит через {time} сек")
            else:
                print("Чайник не включается. Объем воды не соответствует технике безопасности")
        elif water_check == True:
            print("Чайник экстренно выключается. Обнаружена жидкость на поверхности!")
        else:
            print("Неправильно работает датчик воды! Отнесите его в сервисный центр")
    else:
        print("Подключите чайник к сети или павербанку!")

# boile_kettle(400, water_check = False)
# boile_kettle(200, water_check = 123)
# boile_kettle(200, water_check = False, power=200)
# boile_kettle()

# Списки
usb_types = ["Micro USB", "USB 2.0", "USB 3.0", "Type C", "Type A"]
battery_volume = [2000, 3000, 4000, 5000, 8000, 10000, 20000]
battery_type = ["USB 2.0", 3000, 5000, "USB 3.0", "Type C"]

# К спискам можно обращаться по индексу (порядковому номеру). Индекс начинается с 0
# print(usb_types[0])
# print(usb_types[1])
# print(usb_types[-1])     # Выводим последний элемент списка, независимо от количества элементов в нем

# Изменение значения элемента
# print(battery_volume[6])
battery_volume[6] = 25000
# print(battery_volume[6])

# Добавление нового элемента в список
# print(battery_volume)
# battery_volume.append(30000)
# print(battery_volume)

# Удаления элемента из списка
# print(battery_volume)
# battery_volume.pop(0)         # Будет удален элемент по его индексу
# battery_volume.remove(5000)   # Будет удален элемент по его значению
# print(battery_volume)

# Посчитать кол-во элементов списка
# print(f"Количество элементов в списке типов батарей: {len(battery_type)}")

# Циклы в Python — это конструкции, которые позволяют выполнять один и тот же блок кода многократно,
# пока выполняется определённое условие или пока не будут обработаны все элементы в коллекции.

# Цикл For в Python используется для перебора элементов в коллекциях, таких как списки, кортежи, строки и диапазоны
# for u in usb_types:
#     print(f"У меня: {u} USB")

# Пример без цикла:
# print(usb_types[0])
# print(usb_types[1])
# print(usb_types[2])
# print(usb_types[3])
# print(usb_types[4])

# Цикл While выполняет блок кода до тех пор, пока условие остаётся истинным.
# Он проверяет условие перед каждой итерацией, и как только условие становится ложным, цикл завершается.
# x = 1
# while x == 1:     # Аналогичный пример: while True:
#     print("Привет всем!")   # Вечный цикл, поскольку условие х == 1 будет истинно всегда (значение фиксировано)

# x = 5
# y = 1
# while x > y:
#     print(f"{x} больше чем {y}")
#     y = y + 1   # равносильно выражению y += 1


# Операторы break и continue
# Операторы break и continue могут использоваться как в циклах for, так и в циклах while.

# Оператор break служит для завершения выполнения текущего цикла. Когда интерпретатор Python встречает этот оператор,
# выполнение цикла прерывается, и управление передаётся на следующую строку кода, следующую за циклом.
# for b in battery_volume:
#     print(b)
#     if b == 8000:
#         break   # Остановим выполнение цикла когда объем аккумулятора будет равен 8000

# Оператор continue используется для пропуска оставшейся части текущей итерации цикла и перехода к следующей итерации.
# При встрече с этим оператором интерпретатор пропускает все последующие инструкции в теле цикла и начинает новую итерацию.
# Это может быть полезно, когда требуется пропустить выполнение некоторых шагов цикла в зависимости от определённых условий.

# numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 13, 15, 18, 19, 23, 25, 27, 30, 31, 33, 35]
#
# for n in numbers:
#     if n == 6:
#         continue    # Пропускаем вывод числа 6
#     print(f"Ваш номер: {n}")

# Пример с циклом while:
def toaster():
    time = 0
    while time < 120:
        if time == 110:
            break       # Прерываем работу тостера сразу же по достижении 110 секунд
        print(f"Тостер работает {time} секунд")
        time += 1

# toaster()

def even_number():
    z = 0
    while z <= 10:
        z += 1  # z = z + 1
        if z % 2 != 0:
            continue        # В данном условии пропускается каждое НЕЧЕТНОЕ число с помощью оператора continue
        print(f"Четное число: {z}")

# even_number()